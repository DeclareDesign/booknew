---
title: "Specifying the model"
output:
  html_document:
    toc: true
    toc_depth: 2
---

<!-- note do_bookdown is set in index.rmd, so we know if you are running just this .Rmd or compiling the book-->
```{r, eval = !exists("do_bookdown"), echo = FALSE, include = FALSE, purl = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # files are all relative to RStudio project home
```

```{r, eval = !exists("do_bookdown"), echo = FALSE, include = FALSE, purl = FALSE}
# load common packages, set ggplot ddtheme, etc.
source("scripts/before_chapter_script.R")
```

<!-- start post here, do not edit above -->

# Specifying the model

<!-- make sure to rename the section title below -->

```{r specifying_the_model, echo = FALSE, output = FALSE, purl = FALSE}
# run the diagnosis (set to TRUE) on your computer for this section only before pushing to Github. no diagnosis will ever take place on github.
do_diagnosis <- FALSE
sims <- 100
b_sims <- 20
```

```{r, echo = FALSE}
# load packages for this section here. note many (DD, tidyverse) are already available, see scripts/package-list.R
library(dagitty)
library(dddag)
library(ggraph)
```

Any research design -- whether the research question is fundamentally causal or descriptive -- implicitly relies on models. Models can enter at multiple stages, for example in guiding the research question or at the analysis stage. Here we focus on the role of models for a background understanding of how the world works, against which the performance of a design can be assessed. We call these "**reference models**"  (to be distinguished from analytic models later). Their role is to provide a stipulation of how the world works---for instance, what variables are important and how do they interrelate---which allows us to ask questions such as: if the reference model were true, what would the answer to my question be and would I be able to figure out the answer?  

The *M* in MIDA refers to these reference models. As we describe below we often think of *M* as a set of models, with the typical element $m$, though in some cases the *M* may just be a single model.

<!-- Even if the model is hazy, researchers carry with them a model of the world that could in principle be expressed as a probablistic causal model. As described in the previous chapter, probabalistic causal models are described by a set of exogeneous and endogenous variables, a set of functional relationships between the variables, and a probability distribution over the exogenous variables. -->

Critically, whether a design is good or bad depends on the reference model. A data and analysis strategy might fare very well under one model of the world but poorly under another.  Thus to get to the point where we can assess a design we need to make the reference model---or in many cases, the family of reference models---explicit. This chapter is about how to go about this difficult task.

We'll make use of two different formal languages for describing causal models: DAGs and potential outcomes. 

The **potential outcomes** formalization emphasizes a counterfactual notion of causality. $Y_i(Z = 0)$ is the outcome for unit $i$ that *would* occur *were* the causal variable $Z$ equal to zero and $Y_i(Z = 1)$ is the outcome that would occur if $Z$ were set to one. The difference between them defines the effect of the treatment on the outcome for unit $i$. Since at most only one potential outcome can ever be revealed, at least one of the two potential outcomes is necessarily counterfactual. Usually, the potential outcomes notation $Y_i(Z)$ reports how outcomes depend on one feature, $Z$, ignoring all other determinants of outcomes.  This is not to say that these don't matter---they do---they are just not the focus. In a sense, they are contained in the subscript $i$ since the units carry with them all relevant features other than $Z$. We can generalize to settings where we want to focus on more than one cause, in which case we use expressions of the form $Y(0,0)$ or $Y(0,1)$.

The **graphical model** formalization makes use of DAGs or "directed acyclic graphs" to characterize causal relations. Each node on a graph is a variable and the edges that connect them represent possible causal effects. An arrow from a "parent" node to a "child" node indicates that the value of the parent sometimes determines the outcome of the child; more formally: the parent's value is an argument in a functional equation determining the child's outcome. Though consistent with a counterfactual notion of causality, DAGs emphasize mechanistic accounts: when the exposure variable changes, the outcome variable changes as a result---though possibly in different ways for different units. DAGs are *nonparametric*. This means that they do not encode all the beliefs about the full causal model. They don't show *how* variables are related, just *that* they are related.

Defining a reference model requires both defining a set of variables (their meanings and their ranges) and stipulating how they relate to each other. In the potential outcomes framework, these are captured by differences in potential outcomes under different conditions. In the graphical modeling literature, we define a set of nonparametric structural causal relationships, indicating which variables depend on which other variables. With these variables in hand, we can visualize the model using a directed acyclic graph (DAG). 

Despite what you may have inferred from the sometimes heated disagreements between scholars who prefer one formalization to the other, DAGs and potential outcomes are compatible systems for thinking about causality. We *could* use only the language of causal graphs or we *could* use only the language of potential outcomes. We choose to use both languages because they are useful for expressing different facets of research design. We use DAGs to describe the web of causal interrelations in a concise way (writing out the potential outcomes for every relationship in the model is tedious). We use potential outcomes when we want to zoom in on *particular* causal relationships and to make fine distinctions between inquiries that apply to different sets of units (it's difficult to describe effect heterogeneity with graphical models).

We illustrate these ideas using a simple DAG to describe a model with an abstract research design in which we will collect information about $N$ units. We will  assign a treatment $Z$ at random, and collect a posttreatment outcome $Y$. We know there are other determinants of the outcome beyond $Z$, but we don't need to write down our beliefs about them because our main inquiry is the average treatment effect of $Z$ on $Y$. All we'll say about those other determinants is that they are causally related to $Y$, but not to $Z$, since $Z$ will be randomly assigned by us. 

The nonparametric structural equation determining $Y$  can be written like this:

\begin{align*}
Y &= f_Y(Z, U)
\end{align*}

A parametric structural equation can be written like this:

\begin{align*}
Y &= Z + U
\end{align*}

Equivalently, the potential outcomes (for $Y$) might be written, for $i \in \{1,2,\dots, n\}$ as:

\begin{align*}
Y_i(0) &= u_i  \\
Y_i(1) &= 1 + u_i 
\end{align*}

This DAG encodes this model in graphical form:

```{r p2simpledag, echo = FALSE, fig.height = 3.5, fig.width = 7, fig.cap = "Simple DAG. U is unobserved."}
dag <- dagify(Y ~ Z + U)

nodes <-
  tibble(
    name = c("Z", "U", "Y"),
    label = c("Z", "U", "Y"),
    annotation = c(
      "**Treatment assignment**",
      "**Unknown heterogeneity**",
      "**Outcome**"
    ),
    x = c(1, 5, 5),
    y = c(1.5, 3.5,  1.5), 
    nudge_direction = c("S", "N", "S"),
    data_strategy = c("assignment", "unmanipulated", "unmanipulated"),
    answer_strategy = "uncontrolled"
  )

ggdd_df <- make_dag_df(dag, nodes)

base_dag_plot %+% ggdd_df
```

## Visualizing research design elements

The visual display of DAGs typically includes nodes connected by edges

- edges point only to nodes, not to other edges. Some frameworks for visualizing parametric causal models encode the presence of an interaction as an edge pointing to another edge, but we will not use that approach here.

- Pearl (pg. XXX) denotes conditioning on a variable in the answer stragegy with a box around the variable; we do follow this convention.

- CITE introduces intervention nodes -- in that framework, variables that are manipulated by the researcher (as in a random assignement) are marked with a []. In that spirit, we introduce shapes for all three kinds of operations in a data strategy: circles for random assignments, triangles for sampling, and squares for measurement procedures. 

```{r, fig.height = 6, fig.width = 4, echo = FALSE}
# assignment
dag <- dagify(Y ~ D,
              D ~ Z)

nodes <-
  tibble(
    name = c("Z", "D", "Y"),
    label = c("Z", "D", "Y"),
    annotation = c("**Random assignment**",
                   "**Treatment**",
                   "**Observed outcome**"),
    x = c(1, 3, 5),
    y = c(2, 2, 2), 
    nudge_direction = "N",
    data_strategy = c("assignment", "unmanipulated", "unmanipulated"),
    answer_strategy = "uncontrolled"
  )

ggdd_df <- make_dag_df(dag, nodes)

gg_assignment <- base_dag_plot %+% ggdd_df

# sampling
dag <- dagify(Y ~ S)

nodes <-
  tibble(
    name = c("S", "Y"),
    label = c("S", "Y"),
    annotation = c("**Random sampling**",
                   "**Observed outcome**"),
    x = c(1, 5),
    y = c(2, 2), 
    nudge_direction = "N",
    data_strategy = c("sampling", "unmanipulated"),
    answer_strategy = "uncontrolled"
  )

ggdd_df <- make_dag_df(dag, nodes)

gg_sampling <- base_dag_plot %+% ggdd_df


# measurement
dag <- dagify(Y ~ Q + Ystar)

nodes <-
  tibble(
    name = c("Ystar", "Y", "Q"),
    label = c("Y^*", "Y", "Q"),
    annotation = c("**Latent outcome**",
                   "**Observed outcome**",
                   "**Measurement tool**"),
    x = c(1, 3, 5),
    y = c(2, 2, 2), 
    nudge_direction = "N",
    data_strategy = c("unmanipulated", "unmanipulated", "measurement"),
    answer_strategy = "uncontrolled"
  )

ggdd_df <- make_dag_df(dag, nodes)

gg_measurement <- base_dag_plot %+% ggdd_df

# adjustment 
dag <- dagify(Y ~ Z + X)

nodes <-
  tibble(
    name = c("Z", "Y", "X"),
    label = c("Z", "Y", "X"),
    annotation = c("**Treatment assignment**",
                   "**Observed outcome**",
                   "**Pretreatment covariate**"),
    x = c(1, 3, 5),
    y = c(2, 2, 2), 
    nudge_direction = "N",
    data_strategy = c("assignment", "unmanipulated", "unmanipulated"),
    answer_strategy = c("uncontrolled", "uncontrolled", "controlled")
  )

ggdd_df <- make_dag_df(dag, nodes)

gg_adjustment <- base_dag_plot %+% ggdd_df

(gg_assignment + gg_sampling) / (gg_measurement + gg_adjustment)
```



<!-- This is good text but for answer stratgy: -->
<!-- Possibly the most important thing that a DAG can teach us is which research questions are even answerable in a given setting by applying the "back-door criterion," which asks whether a back-door path exists between a pair of causally-related variables. Here, the causal relationship between $X$ and $Y$ is confounded by the back-door path $X \leftarrow U \rightarrow Z$. (for much more on the back-door criterion, see XXX). Since we have no information about what is in $U$, we can't learn about the effects of $X$ on $Y$. However, the treatment variable $Z$ has no edges leading in to it, which represents the idea that $Z$ is randomly assigned. There are no back door paths leading from $Z$ to $Y$, so we *can* learn more easily about average causal effects of $Z$ on $Y$. We could also draw descriptive inferences about the distributions of the observed variables like their ranges and averages or their variances and covariances. -->



## What is the population?

The first choice to make in declaring *M* is the set of units about which you wish to make inferences.  This is largely determined by your inquiry (*I*). We might usefully distinguish between three types of sets of units---all of which we will refer to as your "population." 

* Finite population. If your inquiry is about the population of Americans or Brazilians, your reference model should describe the characteristics of all Americans or Brazilians. You might only analyze data from a sample of these, but you seek nevertheless to make inferences about this (finite) population.

* Finite sample. Moving down, your inquiry might only be about a sample from a finite population. If you are interested in the sample average treatment effect, then you need only  describe only the units in your sample. For practical purposes your sample then *is* your population. Subtly however, if you are interested in a sample but you know the sampling procedure but not which units will be from the population will be yet, then your inquiry might concern a typical sample from a population. Your estimand will change depending on the realized sample.

* Superpopulation. Moving *up*, you might imagine units as being draws from an infinite population. You are interested in "what happens when you shake a fizzy drink?": the set of instances is infinite and when you characterize the superpopulation, you want to describe a distribution over all possible cases, not just a finite set of cases.

Which population you have in mind affects how reference populations should be modeled and also how draws from a population should be interpreted. 

To illustrate consider a very simple model in which we believe that $Y$ depends upon $Z$ and $Z$ is randomly assigned, with probability .5. Say we believe that potential outcomes, and treatment effects, are different for each person. This model, like many in this book, might be declared like this:

```{r}
model <-
  declare_model(N = 100, 
                U = rnorm(N), 
                tau = rnorm(N, mean = 1, sd = 0.1), 
                Z = rbinom(N, 1, prob = 0.5),
                potential_outcomes(Y ~ tau * Z + U))
```

The model can be used to generate data, like this:

```{r realizedmodel, echo = FALSE}
draw_data(model + NULL) %>% 
  head(5) %>% kable(caption = "Data from a simple model", digits = 3, booktabs = TRUE)
```

Note first  that now that this declaration has a stochastic component. Not only is `X` randomized but so are individual level features `U` and treatment effects `tau`.  Note also that the "data" contains potential outcomes---that is, *each draw* includes a description of how the world would work under different conditions and not simply a description of possibly observable data. In other words, it reports a data generating process, not just data.  

There are three distinct ways to interpret this model specification.

1. **Large Population Interpretation of M**: We have a large population---perhaps a superpopulation. On each run of the model we get to see a new sample and we use the sample to learn about the large population. In this interpretation *M* is a singleton---we have specified only one model.

2. **Priors Interpretation of M**: A second interpretation is that the stochastic component represents our uncertainty over a set of possible worlds. It might be, for instance, a design performs well for some possible worlds and poorly for others, in which case the nature of this distribution is important for assessing our *expectation* that a design will perform well. In this interpretation, *M* is again a singleton. 

2. **Multiple Worlds Interpretation of M**: A third interpretation is that each data draw is itself a (non-stochastic) model and the distribution functions provide a handy way of generating multiple plausible models. We want to learn about design performance for each of these possible worlds. Under this interpretation, *M* is a collection of models and we may be interested in performance over each $m$ in *M*. 

Which interpretation we have matters for how we do diagnosis (see Section \@ref(p2diagnosis)).


## What variables to include?

<!-- perhaps give technical definition of a variable -->

### Types of variables

The key components in the model above and all the reference models we examine are the "variables" (or "nodes")  and the ways these stand in relation to each other. Informally, a variable is a quantity that can take on different values: the day of the week, the winner of an election, the height of a mountain. All variables are formally similar but they can play distinguished roles in a model.

Often variables are labeled according to the role they play in a causal model and, in later discussions, we will often refer to variables in this way using the following terms:

1. **Outcome variables**: the variable whose level or responses we want to understand, generally referred to as $Y$, as in Figure \@ref(fig:vartypes). Variously described as "dependent variables," "endogenous variables," "left-hand side variables," "response variables." 
2. **Explanatory variables**: the variables that affect outcome variables, often referred to as $X$s and sometimes as $Z$, *D*, or $W$. We will use *D* most often to refer to the main causal variable of interest in a particular study.
3. **Conditioning** or **moderating** variables. Variables that might alter the effect of *D* on $Y$. See for example $X2$ in Figure \@ref(fig:vartypes). Note that the figure simply indicates that $X2$ is a cause of $Y$ and the graph does not indicate that there is an interaction between $X1$ and $X2$. One account for this is that as a general matter if two variables cause an outcome it would be surprising if they did *not* interact in some way.   
4. **Mediators.** Variables "along the path" between explanatory variables and outcomes. *M* is an example of a mediator in this figure. Mediators are often studied to assess "how" *D* causes $Y$.
5. **Confounders**. Variables that introduce a noncausal correlation between *D* and $Y$. In the figure, $X1$ is an unobserved confounder because it causes both $X$ and $Y$ and could introduce a correlation between them even if *D* did not cause $Y$. 
6. **Instruments.** An instrumental variable is a variable that can induce an exogenous change in an explanatory variable and help us figure out the relationship between *D* and $Y$, it is used instrumentally---not for its own sake. We give a much more detailed treatment of these variables in Section \@ref(p3iv). $Z$ is often reserved for instruments; see Figure \@ref(fig:vartypes).
7. **Colliders.** Colliders are variables that are caused by two other variables. Colliders can be important because conditioning on a collider introduces a statistical but noncausal relationship between the causes of the collider. In figure \@ref(fig:vartypes), $K$ is a collider that can create a correlation between *D* and $Y$ (via $U$) when conditioned upon.

Note that these labels reflect the researcher's interest as much as their position in a model. Another researcher examining the same graph might, for instance, label *M* as their explanatory variable or $K$ as their outcome of interest.

```{r vartypes, echo = FALSE, fig.cap = "A DAG with an explanatory variable of interest (D), an outcome of interest (Y), a mediator (M), a confounder (X1), a moderator (X2), an instrument (Z), and a collider (K)."}

M <-
  declare_model(
    N = 100,
    U = rbinom(N, size = 1, prob = 0.25),
    X1 = rbinom(N, size = 1, prob = 0.25),
    X2 = rbinom(N, size = 1, prob = 0.25),
    potential_outcomes(D ~ Z * X1),
    potential_outcomes(M ~ D, conditions = list(D = c(0, 1))),
    potential_outcomes(K ~ D * U, conditions = list(D = c(0, 1))),
    potential_outcomes(Y ~ X2 + X1 + M + U, 
                       conditions = list(M = c(0, 1)))
  ) +
  declare_assignment(Z = complete_ra(N, prob = 0.5), legacy = FALSE) +
  declare_measurement(
    D = reveal_outcomes(D ~ Z),
    M = reveal_outcomes(M ~ D),
    K = reveal_outcomes(K ~ D),
    Y = reveal_outcomes(Y ~ M)
  )
# draw_data(M)


dag <- dagify(
  Y ~ X2 + X1 + M + U,
  M ~ D,
  K ~ D + U,
  D ~ Z + X1
)

# x = c(M = 3, U = 4, X1 = 3, X2 = 2, X3 = 4, Z = 1, Y = 4, K = 3)
# y = c(M = 1, U = 0, X1 = 2, X2 = 1, X3 = 2, Z = 1, Y = 1, K = 0)

nodes <-
  tibble(
    name = c("Z", "X1", "U", "Y", "X2", "K", "M", "D"),
    label = c("Z", "X1", "U", "Y", "X2", "K", "M", "D"),
    annotation = c(
      "**Instrument**",
      "**Confounder**",
      "**Unknown heterogeneity**",
      "**Outcome**",
      "**Moderator**",
      "**Collider**",
      "**Mediator**",
      "**Explanatory variable**"
    ),
    x = c(1, 3, 5, 5, 5, 3, 3, 2),
    y = c(2.5, 4, 1, 2.5, 4, 1, 2.5, 2.5), 
    nudge_direction = c("N", "N", "S", "E", "N", "S", "N", "S"),
    data_strategy = c("assignment", "unmanipulated", "unmanipulated", "unmanipulated", "unmanipulated", "unmanipulated", "unmanipulated", "unmanipulated"),
    answer_strategy = "uncontrolled"
  )

ggdd_df <- make_dag_df(dag, nodes)

base_dag_plot %+% ggdd_df
```

### What variables are *needed* for declaration and diagnosis?

When considering what variables to include in a model, researchers are often torn between two conflicting goals. First, we want to learn more and more about how the world works or in other words, to fill in more and more of a large causal model. There are an infinite number of nodes and edges in this model --- from how people vote to how they save and spend money to how they find romantic partners, all of which are interrelated. Second, we generally seek simple explanations where possible. Indeed in some accounts, the point of research is to generate simplified representations of the world. The analogy of a map is often used: a useful map usually should have less detail than the object it is mapping. 

We are used to these considerations vying with each other when choosing which variables "of interest" to include in a model. For instance, which are the causes to examine when explaining an outcome. We highlight here that in the MIDA framework, the first consideration -- realism -- likely carries more weight than in other settings. The reason is that the model, as understood here, is not the analysis but *the benchmark against which your analysis will be assessed*. An excellent "analytic model" might ignore unimportant details about a problem, but your reference model might have to specify these details in order to establish that indeed they can be ignored without harming your inferences. 

In the design declaration framework, the variables that we need to specify in *M* are in general comprised of (a) those we will need in the latter three elements in our research design, our inquiry *I*, data strategy *D*, and answer strategy *A*, and (b) those that we need for diagnosis.

Consider the first set first:

*I*: In order to reason about whether the data we collect will be able to provide an answer to our inquiry, we need to define all of the variables used to construct our inquiry. In descriptive research, this will mean the variables we will summarize. In causal research, this will mean the potential outcomes under different states of the world, such as treatment and control. For example, if we are studying the effects of a voter mobilization campaign on vote choice between the three candidates running in a primary election, we should define a vote choice variable and the values it takes on in two circumstances: in the presence of the voter mobilization campaign (treatment) and without it (control).

*D*: The data strategy --- sampling, treatment assignment, and measurement --- defines many of the variables we need to specify in the model. Sampling procedures often involve stratification (e.g., sampling equal proportions of men and women), clustering (e.g., sampling all of the individuals in a household to participate in the research), or both. In the model, we need to define the variables that will be used to stratify and cluster. Similarly, treatment assignment can involve assigning treatments within blocks and cluster assignment where all units are assigned to the same status. The variables that are used to construct blocks and that to form clusters will be defined in the model. Finally, all of the variables that will be measured should also be defined in the model. When we measure latent variables imperfectly, for example sensitive questions where a true characteristic exists but respondents do not always admit it, we should define both the latent trait and measured responses.

*A*: Finally, answer strategies rely on collected data to provide an answer to the inquiry, and so any variable in the collected data should be defined in the model. (Any of these variables should also be defined in the measurement strategy.) Beyond outcomes and treatment variables, we may need variables to define clusters used in clustered standard errors, to construct weights for poststratification of estimates to match population characteristics, and to visualize our data.

If we have all this,  do we have enough for diagnosis? We might not. When we engage in diagnosis we may want to ask about how our design fares if the world worked in a particular way. For instance, the gender of subjects might not be a primary interest for us or enter into our inquiry, our data strategy, or our analysis, but we might worry that gender confounds our inferences---for example if it affects both the treatment uptake and the outcomes. In this case, we may include gender in the reference model in order to assess the extent to which our analysis is sensitive to it.

## Specifying structural relations

DAGs convey beliefs about *whether* two variables are causally related, but they do not encode beliefs about *how* they are related. This is no criticism of DAGs --- they just don't encode all of our causal beliefs about a system. To assess many properties of a research design we need to go further. We need to specify the probability distribution of exogenous variables and the functional forms of the endogenous variables (how they relate to parent variables). This will include incorporating beliefs about effect sizes, but also correlations between variables, intra-class correlations (ICCs), and interactions. All of this to say: in order to declare and diagnose our designs, we will need to make the leap from nonparametric models to *parametric* structural causal models. This move is not without costs -- each specific choice we make over and above the nonparametric model is an opportunity to be more wrong about the world!

A slightly more complex example helps demonstrate how we can use a model declaration to facilitate the representation of a class of possibly stochastic models. Suppose that according to our model, the effect of $Z$ should be larger for units with $X = 1$. We can encode this belief in the design declaration below. In the `declare_population` function, we write that $U$ is normally distributed with mean 0 and standard deviation 1; $X$ follows a Bernoulli distribution. In the `declare_potential_outcomes` function, we describe how the average effect of treatment depends on $X$.

<!-- I removed the confounding to keep focused on one point -->

```{r}
tau_X0 <- 0.5
tau_X1 <- 1

model <-
  declare_model(
    N = 100, 
    U = rnorm(N), 
    X = rbinom(N, 1, .5),
    potential_outcomes(
      Y ~ (X == 0) * Z * tau_X0 + (X == 1) * Z * tau_X1 + U
    )
  )
```

The design describes a more complex world in which treatment effects of $Z$ depend in a particular way on a background variable $X$. We could incorporate different beliefs about the causal model by changing the `tau_X0` and `tau_X1` parameters. However, regardless of the value of the interaction (either zero or some other number), the DAG looks the same but the ability of the design to answer questions of interest will vary. This highlights the point that DAGs themselves are not enough to characterize a model---design declaration requires functional equations also: either specific equations or families of equations. Thus, although we might feel uncomfortable specifying particular values for `tau_X0` and `tau_X1`, we are not beholden to these particular values. We can easily vary them to see how a design performs over a range of models, or we could even expand the declaration to specify a distribution of values for `tau_X0` and `tau_X1`. 

<!-- maybe a footnote? -->
<!-- - some of these variables will be exogenous and endogenous, in Pearl's terms. by exogenous variables, he means variables without parents, no antecendent causes. by endogenous variables, he means those with parents, that are determined in part by earlier variables. endogenous variables are distinct from the problem of endogeneity, which comes from a single variable being a parent of both the treatment variable of interest and the outcome we wish to measure the causal effect of the treatment on. we will use it in Pearl's sense. -->

<!-- maybe should clarify somewhere that the choice of a distribution function is as much a parametric decision as the choice of its arguments -->

## Substantive justifications for choices of nodes and equations

So far we have described formal considerations but we have not described substantive considerations for including particular variables or stipulating particular relations between them. 

The justification for your choice of reference model will depend on the purpose of your design. Broadly we distinguish between reality tracking models, discursive models, and sufficient models. 

### Reality tracking models

Reality tracking reference models seek to approximate the truth as well as possible. 

The content of these models typically comes from two places: reading the past literature and qualitative research. Past theoretical work can guide the set of nodes that are relevant and how they are connected by edges. Past empirical work can provide further insight into the set of edges that exist (or do not). However, when past research is thin on a topic, there is no substitute for insights gained through qualitative data collection: focus groups and interviews with key informants who know aspects of the model that are hidden from the researcher; archival investigations to understand a causal process when the actors in it are no longer alive, or to gain insights only contained in administrative records; and immersive participant observation to see with your eyes how social actors behave. @fenno1978home calls this "soaking and poking." This mode of inquiry, discovery, is separate from the qualitative research designs that provide an answer to an inquiry deductively. We examine those throughout the book. Instead, qualitative insights such as this, which @lieberman2005nested labels "model-building" case studies, do not aim to answer a question but rather yield a new theoretical model. Quantitative research is often seen as distinct from qualitative research, but the model building phase in both is itself qualitative.

The next step --- selecting statistical distributions and their parameters to describe exogenous variables and the functional forms of endogenous variables --- is often more uncomfortable. We do not know the magnitude of the effect of an intervention before we do the research or the correlation between two outcomes when those are the goal of the research. That's why we are conducting the study! However, we are not fully in the dark in most cases and can make educated guesses about parameters like effect sizes, intraclass correlations, and correlations between variables.

We can conduct meta-analyses of past relevant studies on the same topic to identify the range of plausible effect sizes, intraclass correlations, correlations between variables, and other model parameters. Conduct such a meta-analysis might be as simple as collecting the three papers that measured similar outcomes in the past and calculating the average intraclass correlation and its range across the three. A more sophisticated but still straightforward analysis would be to calculate the precision-weighted average of effect sizes and use that as the baseline effect size in the model, but also calculate the predictive interval from a random effects meta-analysis to characterize the expected range of effect sizes across differing contexts.

The key question in conducting such a meta-analysis is how to select studies that are "relevant." There are four dimensions on which we might want to compare past studies to the current setting: similarity in the type of units, treatments, outcomes, and contexts [@cronbach1982]. Except in the case of pure replication studies, we are typically studying a (possibly new) treatment in a new setting, with new participants, or with new outcomes, so there will not be perfect overlap. However, the variation in effects across contexts and these other dimensions will help structure the range of our guesses specified in the model.

When there are past studies that are especially close to our own, we may want to not define probability distributions that approximate the causal model of the world, but use the data from that past study directly as a stand-in. To do so, instead of declaring variables and their distributions and potential outcomes, we can resample from the past data to obtain simulated alternative possible worlds.

Where there are no past studies that are sufficiently similar in some dimensions, we can collect new data through pilot studies. We discuss the risks of relying on data from small pilot studies in planning new research in Chapter \@ref(p4piloting). In short, we should not rely on effect size estimates from small pilot studies, and only use parameters such as the range of outcome data and the standard errors of estimates which are less noisy in declaring our new design.

In some cases, we can define many of the variables from early data collection in a study, e.g., from a baseline survey. Once we conduct a baseline survey, we can use the set of individuals selected for the study and their baseline characteristics to define many of the variables in our model. We can define our expectations about effect sizes and other features of endogenous variables, but rely on the correlations between exogenous variables from the baseline data. The danger here is that if we fix the characteristics of our model using baseline data, we will not consider what data *could have* been revealed if our sampling procedure had yielded a different set of study participants or we had conducted data collection a month later.

### Discursive models

For some purposes, the reference model might be developed not to track reality, but to reflect assumptions in a scholarly debate. For instance, the purpose might be to question whether a given conclusion is valid **under the assumptions maintained by some scholarly community**. Indeed it is possible that a reference model is used specifically because the researcher thinks it is inaccurate, allowing them to show that even if they are wrong about some assumptions about the world in *M*, their analysis will produce useful answers. 

A particularly important class of discursive models are what might be called "agnostic models": models that make weaker assumptions about the world than the researcher in good faith holds. In a directed acyclic graph, every arrow indicates a possible relation between a cause and an outcome. The big assumptions in these models, however, are not seen in the arrows but the absence of arrows: every missing arrow represents a claim that an outcome is not affected by a possible cause.  Analysis strategies often depend upon such assumptions. Even when arrows are included, functional relations might presuppose particular features important for inference. For instance, a researcher using "instrumental variables" analysis will generally assume that $Z$ causes $Y$ through *D* but not through other paths. This is an assumption about absent arrows. The same analysis might also assume that $Z$ never affects *D* negatively. That is an assumption about functional forms. An agnostic reference model might loosen these assumptions, allow for the possibility of violations of exclusion restrictions and violations of monotonicity assumptions and use this to see how analysis fares under conditions that the researcher believes not to be true, but that a skeptic might be willing to entertain.     

### Sufficient models

For some purposes, the validity of inferences or the lessons learned from a diagnosis do not depend on the realized world $w$ being among the set of possible draws of *M* `r flagit()`, the relevant question is only whether the kinds of inferences one might draw given stipulated reference models would also hold reasonable well for the true data generating process. For instance, if your aim is to assess whether an analysis strategy generates an unbiased estimate of a treatment effect you may go to pains to make sure that that you model treatment assignment carefully but modeling the size of a treatment effect correctly may not be important. The idea is that what you learn from the model that you do study is sufficient for inferences about a broader class of models within which the true data generating process might lie.       

## Getting it right?

### Robustness to multiple models

We noted that the most uncomfortable part of declaring *M* is choosing point estimates of its parameters such as the effect size, the mean and variance of the normal distribution that describes unknown heterogeneity. But we also emphasized that there is in general no need to specify a single point! Indeed, our uncertainty about the model should usually lead us to a range or even empirical distribution from past studies of each parameter.

We suggest three strategies for choosing these ranges: the *logical bounds* of a parameter, such as choosing the range of possible effect sizes based on the largest change from the bottom of a scale to the top of a scale; the *empirical distribution* from past studies, either the full range of the parameter or the predictive interval from a random effects meta-analysis; or a *best case*-*worst case* bounds, based on the substantive interpretation of results in light of past results, for example ranging from an effect size of zero to the largest plausible effect size. A design that performs well in terms of power and bias under one or all of these three ranges for each parameter might be labeled "robust to multiple models."

A separate goal is assessing the performance of a research design under different models implied by alternative theories. A good design will provide probative evidence about which model is correct regardless of which model it is that aligns with the true causal model of the world.

An important example is assessing the performance of a research design under a "null model" where the true effect size is zero. A good research design should report with a high probability that there is insufficient evidence to reject a null effect. That same research design, under an alternative model with a large effect size, should with a high probability return evidence rejecting the null hypothesis of zero effect. The example makes clear that in order to understand whether the research design is strong, we need to understand how it performs under not just multiple models, but the models implied by alternative theoretical understandings of the world.

Two alternative theories of why $X$ causes $Y$, through mediator $M_1$ or mediator $M_2$ (and not both), imply two different structural causal models. When the inquiry is which variable mediates the relationship, we need to understand how the research design performs in providing evidence for which is correct under both possibilities.

### Fundamental uncertainty

Even the best reference models are sure to be simplifications of the true data generating process. The true causal structure of the world $W$ generates draws from the world $w$. The inquiry *I* might not even be defined under $W$. That is, $I(w)$ might be $NA$. Applying the data strategy *D* to $w$ might produce unexpected results. That is, $D(w)$ need not be anything like $D(m)$. This disjuncture is in large part the point of doing research in the first place. We do not know $W$ -- that would require omniscience. We have learned parts of $W$ and put them in *M* -- that's science. When research produces unexpected results, it's an indication that something in MIDA is out of whack and it is an opportunity for learning. The *next* research project will amend MIDA in order to bring *M* closer to $W$.

## Sets of models

Every research design starts with a small part of $W$ to study, often a hypothesized relationship between two variables *D* and $Y$. We return at the end of the section to an even simpler starting point: a single variable $Y$ that we wish to describe. Our initial model describes just this "starting point":

```{r DYdag, fig.cap = "Starting model.", echo = FALSE, fig.width=6.5, fig.height=0.25}
dag1 <- dagitty("dag{
                D -> Y
                }")

points_df_small <-
  tibble(name = c("D", "X", "Y", "U"),
         x = c(0, 1, 1, 0),
         y = c(0, 1, 0, 1))
ends_df_small <-
  tibble(to = c("D", "X", "Y", "U"),
         xend = c(0, 1, 1, 0),
         yend = c(0, 1, 0, 1))

gg_df_small <-
  list(dag1) %>%
  map_df( ~ as_tibble(tidy_dagitty(.)), .id = "dag") %>%
  select(-x, -y, -xend, -yend) %>%
  left_join(points_df_small) %>%
  left_join(ends_df_small)

ggplot(gg_df_small %>% filter(name %in% c("D", "Y")), aes(x, y)) +
  geom_text(data = points_df_small %>% filter(name %in% c("D", "Y")), aes(label = name)) +
  geom_dag_edges(aes(xend = xend, yend = yend)) +
  coord_fixed(ylim = c(-0.1, 0.1), xlim = c(-.1, 1.1)) +
  theme_void()
```

In order to consider how our design fares under alternative possible models, which do or do not have a causal relationship between *D* and $Y$, we first expand the model to included unmeasured characteristics $U$ and measured characteristics $X$ of units. These variables may serve as confounders, colliders, mediators, moderators, or instruments. In fact, we consider all of these possibilities for both variables by expanding to all possible relationships between *D*, $Y$, $U$, and $X$. There are six edges between these variables, each with three possible relations: each variable may cause (e.g., $D \rightarrow Y$), be caused by (e.g., $D \leftarrow Y$), or not be causally related to every other variable. With three possible relationships and six edges, there are $3^6 = 729$ conceptually possible DAGs. We rule out DAGs in which other variables cause $U$, because we defined $U$ as an unobserved confounder. This leaves 216 possible combinations. We do not know which one! Our goal as researchers is to narrow down the possible DAGs.

```{r make-all-models-ch2, echo = FALSE}
possible_models <-
  expand.grid(
    XU = c("X<-U", "none"),
    YU = c("Y<-U", "none"),
    YX = c("Y->X", "Y<-X", "none"),
    DU = c("D<-U", "none"),
    DX = c("D->X", "D<-X", "none"),
    DY = c("D->Y", "D<-Y", "none"),
    stringsAsFactors = FALSE
  )

possible_models <-
  possible_models %>%
  rowwise() %>%
  mutate(
    var = str_c(XU, YU, YX, DU, DX, DY, sep = ";"),
    var = str_remove_all(var, "none;"),
    var = str_remove_all(var, "none"),
    dag = list(dagitty(paste0(
      "dag{", var, "; X; D; Y; U}"
    ))),
    acyclic = isAcyclic(dag),
    consistent_with_ignorability = !(DU == "D<-U" & YU == "Y<-U"),
    id_if_adjusted = isAdjustmentSet(dag, "X", exposure = "D", outcome = "Y"),
    id_if_unadjusted = isAdjustmentSet(dag, NULL, exposure = "D", outcome = "Y"),
    id_adjustment_fac = as.factor(
      case_when(
        id_if_unadjusted &
          id_if_adjusted ~ "Yes, regardless of conditioning",
        id_if_unadjusted &
          !id_if_adjusted ~ "Only when NOT conditioning on X",!id_if_unadjusted &
          id_if_adjusted ~ "Only when conditioning on X",!id_if_unadjusted &
          !id_if_adjusted ~ "No, regardless of conditioning"
      )
    ),
    consistent_with_RA = DU != "D<-U" &
      DX != "D<-X" & DY != "D<-Y",
    consistent_with_X_pretreatment =
      DX != "D->X" &
      YX != "Y->X" &
      !(DU == "D->U" & XU == "X<-U") &
      !(YU == "Y->U" & XU == "X<-U")
  ) 

nested_data <-
  possible_models %>%
  filter(var != "") %>%
  mutate(dag_data = list(as_tibble(tidy_dagitty(dag))))

points_df <-
  tibble(name = as.factor(c("D", "X", "Y", "U")),
         x = c(1, 2, 2, 1),
         y = c(1, 2, 1, 2))
ends <-
  points_df %>%
  rename(to = name,
         xend = x,
         yend = y)

fix_no_edges <-
  tibble(
    var = "no edges",
    acyclic = TRUE,
    consistent_with_RA = TRUE,
    consistent_with_X_pretreatment = TRUE,
    XU = "none",
    YU = "none",
    YX = "none",
    DU = "none",
    DX = "none",
    DY = "none",
    name = "X",
    id_adjustment_fac = "Yes, regardless of conditioning"
  )

gg_df <-
  nested_data %>%
  unnest(cols = dag_data) %>%
  select(-x, -y, -xend, -yend) %>%
  left_join(points_df) %>%
  left_join(ends) %>%
  bind_rows(fix_no_edges) %>%
  mutate(
    XU_fac = factor(
      XU,
      levels =  c("X<-U", "X->U", "none"),
      labels =  c("X %<-% U", "X %->% U", "X~~~U")
    ),
    YU_fac = factor(
      YU,
      levels =  c("Y<-U", "Y->U", "none"),
      labels =  c("Y %<-% U", "Y %->% U", "Y~~~U")
    ),
    YX_fac = factor(
      YX,
      levels =  c("Y<-X", "Y->X", "none"),
      labels =  c("Y %<-% X", "Y %->% X", "Y~~~X")
    ),
    DU_fac = factor(
      DU,
      levels =  c("D<-U", "D->U", "none"),
      labels =  c("D %<-% U", "D %->% U", "D~~~U")
    ),
    DX_fac = factor(
      DX,
      levels =  c("D<-X", "D->X", "none"),
      labels =  c("D %<-% X", "D %->% X", "D~~~X")
    ),
    DY_fac = factor(
      DY,
      levels =  c("D<-Y", "D->Y", "none"),
      labels =  c("D %<-% Y", "D %->% Y", "D~~~Y")
    )
  ) %>%
  arrange(XU_fac, YU_fac, YX_fac, DU_fac, DX_fac, DY_fac)

gg_df <-
  gg_df %>%
  mutate(
    var_fac = factor(var, levels = c(possible_models$var, "no edges")),
    DY_DX = as.factor(paste0(DY, " ", DX)),
    U_relationship = paste0(XU, " ", YU, " ", DU),
    U_relationship_fac =
      factor(
        U_relationship,
        levels = c(
          'X<-U Y<-U D<-U',
          'none Y<-U D<-U',
          'X<-U none D<-U',
          'X<-U Y<-U none',
          'none none D<-U',
          'none Y<-U none',
          'X<-U none none',
          'none none none'
        ),
        labels = c(
          "U affects: D, X, Y",
          "U affects: D, Y",
          "U affects: D, X",
          "U affects: X, Y",
          "U affects: D",
          "U affects: Y",
          "U affects: X",
          "U affects: none"
        )
      ),
    ruled_out_by = as.factor(
      case_when(
        !acyclic ~ "Acyclicity",!consistent_with_RA ~ "Random assignment",!consistent_with_X_pretreatment ~ "Measuring X before treatment",
        TRUE ~ NA_character_
      )
    )
  )
```

```{r dagsacyclicity, fig.cap = "216 possible DAGs with acyclicity.", echo = FALSE, fig.width = 40, fig.height = 35}
gg_df <-
  gg_df %>%
  mutate(tile_fac = as.factor(if_else(
    !acyclic,
    "Ruled out by acyclicity",
    "Possible"
  ))
  )

fill_scale <- c(
  `Ruled out by acyclicity` = dd_light_gray,
  `Possible` = "transparent"
)

subplot_function <- function(data) {
  dag_df <-
    data %>%
    group_by(var, DX_fac, YX_fac, tile_fac) %>%
    summarize(x = 1.5, y = 1.5, n = n(), .groups = "drop")
  
  g <-
    ggplot(data, aes(x, y)) +
    geom_tile(data = dag_df, aes(fill = tile_fac), height = 1.75, width = 1.75, alpha = 0.5) +
    geom_text(data = points_df, aes(label = name), size = 5) +
    geom_dag_edges(aes(xend = xend, yend = yend),
                   edge_width = 0.4,
                   arrow_directed = grid::arrow(length = grid::unit(4, "pt"), type = "closed")) +
    scale_fill_manual("Ruled out by acyclicity?", values = fill_scale, drop = FALSE, 
                      guide = guide_legend(nrow = 2, override.aes = list(color = c(rep("white", 1), gray(0.4))))) +
    facet_grid(YX_fac ~ DX_fac, switch = "both", labeller = label_parsed) +
    coord_fixed() +
    theme_void() +
    theme(plot.title = element_text(size = 30, hjust = 0.5),
          plot.subtitle = element_text(size = 30, hjust = 0.5),
          plot.margin = margin(10, 10, 25, 10, unit = "pt")) +
    labs(subtitle = parse(text = as.character(unique(data$DY_fac))))
  if(as.character(unique(data$DY_fac)) == "D %->% Y"){
    g <- g + labs(title = as.character(unique(data$U_relationship_fac)))
  }
  g
}

my_fun <- function(data){
  data %>%
    split(.$DY_fac) %>%
    map(~subplot_function(.)) %>%
    wrap_plots(nrow = 1)
}

gg <- gg_df %>%
  split(.$U_relationship_fac) %>%
  map(my_fun)

wgg <- wrap_plots(gg, ncol = 2, byrow = FALSE) + plot_layout(guides = "collect") &
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 35),
    legend.text = element_text(size = 35),
    legend.key.size = unit(35, "mm"),
    legend.margin = margin(t = 40, r = 0, b = 0, l = 0, unit = "mm"),
    strip.text = element_text(size = 30)
  )

wgg
```

We illustrate possible beliefs about these edges by visualizing all of the 216 DAGs in which $U$ is an unobserved confounder (see Figure \@ref(fig:dagsadjustment)). The large groups of three squares of nine group DAGs based on how $U$ affects other variables in the model: the top left grouping of 27 DAGs represents those in which $U$ affects all of *D*, $X$ and $Y$. Within that grouping, there are three squares of nine squares. Each group of nine squares represents a set of DAGs with a single relationship between *D* and $Y$. The top left group of nine are those DAGs in which $D\rightarrow Y$.

After enumerating each possibility, we draw on logic, theory, and past evidence to rule out implausible or impossible models. We do so judiciously: any model we rule out represents the addition of a possibly false assumption. Past evidence or a theoretical model may provide conclusive reasons to include or exclude certain edges in the reference models. One common exclusion is the assumption of acyclicity: we commonly operate under the view that cycling is not possible in the world, which would imply that these variables simultaneously cause each other. In Figure \@ref(fig:dagsadjustment), DAGs in gray are ruled out by acyclicity.

The final step in setting up our model is defining a mapping between theory and these possible DAGs. Our aim is to provide evidence about generalizable theories, and to do so we must know which theories are ruled in or out by empirical evidence. The first step to doing this is to define which DAGs are consistent or inconsistent with each theory. (Later, we will define what evidence will result in rejection or retention of each DAG; the two steps together will allow us to define which theories are rejected or retained from the evidence.)

For example, we code each model in which *D* causes $Y$ as consistent with "Theory A" and all those in which *D* does not cause $Y$ as consistent with "Theory B" in Table \@ref(tab:theorydags). 

```{r theorydags}
possible_models %>% 
  ungroup %>% 
  sample_n(size = n(), replace = FALSE) %>% 
  mutate(theory_A = DY == "D->Y",
         theory_B = DY == "D Y") %>% 
  select(var, theory_A, theory_B) %>% 
  head() %>% 
  kable(caption = "DAGs coded by consistency with two theories.")
```

With these DAGs in mind, we can declare a design in which we turn on and off each causal relationship:  

```{r diagnosisundermultiplemodels, eval = FALSE}
model <-
  declare_model(
    N = 100, 
    U = rnorm(N), 
    D = rbinom(N, 1, prob = 0.5),
    X = runif(N),
    potential_outcomes(Y ~ DY * Z + YU * U + YX * X)
  )

designs <- redesign(model, DY = c(0, 1), YU = c(0, 1), YX = c(0, 1))

diagnose_design(designs, sims = 5)
```

<!-- 1. identify a small subgraph of interest to study -->
<!-- 2. enumerate all possibilities for the subgraph as M-vector, which is the set we are uncertain over. (ideally we want to be able to say you have provably exploded to the whole ) -->
<!-- 3. rule out sparingly *by assumption* any M in M-vector that past evidence or logic suggest are not W (e.g., acyclicity).  -->
<!-- 4. define mapping of models in M-vector to theories. Some models can result under a theory, others cannot. -->


