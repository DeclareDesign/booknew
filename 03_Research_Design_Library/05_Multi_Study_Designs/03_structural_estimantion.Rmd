---
title: "Structural estimation"
output: html_document
bibliography: ../../bib/book.bib 
---

<!-- note do_bookdown is set in index.rmd, so we know if you're running just this .Rmd or compiling the book-->
```{r, eval = !exists("do_bookdown"), echo = FALSE, include = FALSE, purl = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # files are all relative to RStudio project home
```

```{r, eval = !exists("do_bookdown"), echo = FALSE, include = FALSE, purl = FALSE}
# load common packages, set ggplot ddtheme, etc.
source("scripts/before_chapter_script.R")
```

<!-- start post here, do not edit above -->

<!-- make sure to rename the section title below -->

```{r multi_site_studies, echo = FALSE, output = FALSE, purl = FALSE}
# run the diagnosis (set to TRUE) on your computer for this section only before pushing to Github. no diagnosis will ever take place on github.


packages <- c("bbmle")

invisible(lapply(packages, function(x) if (!require(x, character.only=T)){install.packages(x);library(x, character.only = T)}))

rm(packages)

do_diagnosis <- FALSE
sims <- 1000
b_sims <- 1000
```

```{r, echo = FALSE}
library(metafor)
library(car)
```

## Structural estimation


We imagine a benchamrk model that is consistent with an economic model of bargaining between pairs of players.
The model is taken from Wilke and Humphreys (2020). 

### Design

We make use of a maximum likelihood estimator that takes the model form and identifies which parmater values are most consistent with the data (which collection of parameter values produce the observed data with greatest likelihood). 

```{r}
structural_estimator <- function(data,
                                 Y = "Y_2_obs",
                                 # function to calculate
                                 # predicted price for rational
                                 # customers given z_i and delta,
                                 # defaults to n=2:
                                 y = function(Z, d)
                                   Z * d + (1 - Z) * (1 - d))
  
{
  # Define negative log likelihood as a function of kappa, delta and q
  LL  <- function(k, d, q) {
    m <- with(data, y(Z, d))
    R <- q * dbeta(data[Y][[1]], k * 3 / 4, k * 1 / 4) +
      (1 - q) * dbeta(data[Y][[1]], k * m, k * (1 - m))
    - sum(log(R))
    
  }
  
  # Estimation
  M <- mle2(
    LL,
    method = "L-BFGS-B",
    start = list(k = 2, d = 0.50,  q = 0.50),
    lower = c(k = 1,    d = 0.01,  q = 0.01),
    upper = c(k = 1000, d = 0.99,  q = 0.99)
  )
  
  # Format output from estimation
  out <- data.frame(coef(summary(M)), outcome = Y)
  
  names(out) <- c("estimate", "std.error", "statistic",
                  "p.value", "outcome")
  
  # Use estimates of q and delta to predict average treatment effects (ATEs)
  
 
  # Predicted ATE for n=2
  out[4, 1] <- (1 - out["q", "estimate"]) * (2 * out["d", "estimate"] - 1)
  
  # Predicted ATE for n=infinity
  out[5, 1] <- (1 - out["q", "estimate"]) * (2 * out["d", "estimate"] /
                                               (1 + out["d", "estimate"]) - 1)
  
  out
}
```

The design makes use of this estimator to estimate parameter values as well as treatment effects. It is accompanied by a simpler difference in means estimator of treatment effects.

```{r}
# Declare the design ----------------------------------------------------------

# Define parameter values:

N = 500       # Sample size
d = 0.8       # True delta (unknown)
k = 6         # Nuisance parameter that affects variance (unknown)
q = 0.5       # Share of behavioral types in the population (unknown)
e = 3/4       # Price paid by behavioral customers (known)
random = TRUE # Switch to control whether 
# first movers are randomly assigned

# Design declaration:

design <- 
  
  # Define the population 
  declare_population(N = N, 
                     # indicator for behavioral type (norm = 1)
                     norm = rbinom(N, 1, q), 
                     # probablity of going first without random assignment
                     p = ifelse(norm == 1, .8, .5) 
  ) +
  
  # Define mean potential outcomes for n = 2 
  declare_potential_outcomes(Y_2 ~ norm*e + (1-norm)*(Z*d + (1-Z)*(1-d))) +
  
  # Define mean potential outcomes for n = infinity
  declare_potential_outcomes(Y_inf ~ norm*e + 
                               (1-norm)*(Z*d/(1+d) +
                                           (1-Z)*(1-d/(1+d)))) +
  
  # Define estimands (quantities we want to estimate)
  declare_estimand(ATE_2 = mean(Y_2_Z_1 - Y_2_Z_0),       # ATE n = 2
                   ATE_inf = mean(Y_inf_Z_1 - Y_inf_Z_0), # ATE n = infinity
                   k = k,                                 # kappa
                   d = d,                                 # delta
                   q = q) +                               # q

  # Declare assignment process (random assignment if random = TRUE)
  declare_assignment(prob_unit = if(random) rep(0.5, N) else p, simple = TRUE) +
  
  # Declare revealed potential outcomes
  declare_reveal(Y_2,   Z) +
  declare_reveal(Y_inf, Z) +
  
  # Get draws from beta distribution given means for n = 2 and n = infinity
  declare_step(fabricate, Y_2_obs   = rbeta(N, Y_2*k, (1-Y_2)*k),      
               Y_inf_obs = rbeta(N, Y_inf*k, (1-Y_inf)*k)
  ) +
  
  # Declare estimators
  
  # Difference-in-means for n = 2
  declare_estimator(Y_2_obs ~ Z, 
                    estimand = "ATE_2", 
                    label = "DIM_2") +
  
  # Difference-in-means for n = infinity
  declare_estimator(Y_inf_obs ~ Z, 
                    estimand = "ATE_inf", 
                    label = "DIM_inf") +
  
  # MLE for n = 2
  declare_estimator(handler = tidy_estimator(structural_estimator), 
                    estimand = c("k","d", "q", "ATE_2", "ATE_inf"), 
                    label = "Struc_2") +
  
  # MLE for n = infinity
  declare_estimator(handler = tidy_estimator(structural_estimator),
                    Y = "Y_inf_obs", 
                    y = function(Z, d) Z*d/(1+d) +  (1-Z)*(1-d/(1+d)),
                    estimand = c("k","d","q","ATE_2", "ATE_inf"), 
                    label = "Struc_inf") 
```


```{r, echo = FALSE, eval = do_diagnosis & !exists("do_bookdown")}
diagnosis <- diagnose_design(design, sims = sims, bootstrap_sims = b_sims) 
```


```{r, echo = FALSE, purl = FALSE}
# figure out where the dropbox path is, create the directory if it doesn't exist, and name the RDS file
rds_file_path <- paste0(get_dropbox_path("structural"), "/humphreys_wilke.RDS")
if (do_diagnosis & !exists("do_bookdown")) {
  write_rds(diagnosis, path = rds_file_path)
}
diagnosis <- read_rds(rds_file_path)
```

```{r structuraldiagnosis, echo = FALSE}
diagnosis %>%
  reshape_diagnosis() %>%
  select(-Coverage, -'Mean Se', - 'N Sims', - 'Type S Rate', - Term) %>%
  kable(digits = 3, booktabs = TRUE, caption = "Complete random sampling design diagnosis")
```

