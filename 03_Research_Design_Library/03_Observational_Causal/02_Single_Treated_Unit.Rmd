---
title: "Observational causal inference with a single unit"
output:
  pdf_document: default
  html_document: default
bibliography: ../../bib/book.bib
---

<!-- note do_bookdown is set in index.rmd, so we know if you're running just this .Rmd or compiling the book-->
```{r, eval = !exists("do_bookdown"), echo = FALSE, include = FALSE, purl = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # files are all relative to RStudio project home
```

```{r, eval = !exists("do_bookdown"), echo = FALSE, include = FALSE, purl = FALSE}
# load common packages, set ggplot ddtheme, etc.
source("scripts/before_chapter_script.R")
```

<!-- start post here, do not edit above -->

<!-- make sure to rename the section title below -->

```{r observational-multiple-units, echo = FALSE, output = FALSE, purl = FALSE}
# run the diagnosis (set to TRUE) on your computer for this section only before pushing to Github. no diagnosis will ever take place on github.
do_diagnosis <- FALSE
sims <- 100
b_sims <- 20
```

```{r, echo = FALSE}
library(Synth)
```

## Observational causal inference for a single unit

We often start a causal investigation wanting to know the causal effect for a single unit. For a unit that experienced an event or process, we want to know the causal effect of that event. To do so, we need to know what would have happened if the event did not happen, the *counter*factual outcome as opposed to the factual outcome that actually occurred. Due to the fundamental problem of causal inference, we cannot *observe* what would have happened if that counterfactual case had happened. The event can either happen, or not happen, to each unit. As a result, we have to guess what would have happened. Social scientists have developed a large array of tools for guessing, or imputing, the missing counterfactual outcome --- what would have happened in the counterfactual case, if the event had not happened.^[We are also interested in the opposite case sometimes: we have a unit that did not experience an event, and we want to know the causal effect of *not* having it. In this case, we need to guess what would have happened if the event did happen. The same tools apply in reverse.]

### Qualitative imputation

The simplest idea for imputing missing potential outcomes is to guess based on an assessment of the qualitative evidence for the case. 

### Over-time change within unit

A second natural idea for guessing what would have happened if an event did not occur for a single unit is to look within that unit at what happened *before* the event did occur. Within-unit over-time comparisons use outcomes in pretreatment periods to impute the posttreatment counterfactual outcome. 

```{r}
design <- 
  declare_population(
    N = 2, 
    time = 1:2,
    U_time = rnorm(N),
    potential_outcomes(
      Y ~ time_trend * time + time_specific_effect * U_time + 0.5 * Z
    ),
    Z = 1
  ) + 
  declare_estimand(ATT = mean(Y_Z_1 - Y_Z_0), subset = time == 2) + 
  declare_measurement(Y = ifelse(time == 1, Y_Z_0, Y_Z_1)) + 
  declare_estimator(
    estimate = mean(Y[time == 2]) - mean(Y[time == 1]), 
    estimand_label = "ATT", handler = summarize)
```

```{r}
designs <- redesign(
  design, time_trend = c(0, 0.5), time_specific_effect = c(0, 1))

diagnosis <- diagnose_design(designs, diagnosands = declare_diagnosands(bias = mean(estimate - estimand)))

get_diagnosands(diagnosis) %>% select(time_trend, time_specific_effect, bias) %>% round(2)
```

### Posttreatment difference

```{r}
design <- 
  declare_population(
    N = 2, 
    time = 2,
    U_unit = rnorm(N),
    potential_outcomes(Y ~ 0.5 * Z + unit_specific_effect * U_unit),
    Z = if_else(U_unit == max(U_unit), 1, 0)
  ) + 
  declare_estimand(ATT = mean(Y_Z_1 - Y_Z_0), subset = time == 2) + 
  declare_measurement(Y = ifelse(Z == 0, Y_Z_0, Y_Z_1)) + 
  declare_estimator(
    estimate = mean(Y[Z == 1]) - mean(Y[Z == 0]), 
    estimand_label = "ATT", handler = summarize)
```

```{r}
designs <- redesign(design, unit_specific_effect = c(0, 1))

diagnosis <- diagnose_design(designs, diagnosands = declare_diagnosands(bias = mean(estimate - estimand)))

get_diagnosands(diagnosis) %>% select(unit_specific_effect, bias) %>% round(2)
```

### Difference-in-difference 

```{r}
design <- 
  declare_population(
    unit = add_level(N = 2, U_unit = rnorm(N, sd = 0.5), Z = if_else(U_unit == max(U_unit), 1, 0)),
    period = add_level(N = 2, time = 1:2, U_time = rnorm(N), nest = FALSE),
    unit_period = cross_levels(
      by = join(unit, period), 
      U = rnorm(N, sd = 0.01),
      potential_outcomes(Y ~ time_trend * 0.5 * time + time_specific_effect * U_time + 
          unit_specific_effect * U_unit + 
            1.25 * Z + U),
      Y = if_else(Z == 0 | period == 1, Y_Z_0, Y_Z_1)
    )
  ) + 
  declare_estimand(ATT = mean(Y_Z_1 - Y_Z_0), subset = period == 2) + 
  declare_estimator(
    estimate = 
      (mean(Y[Z == 1 & time == 2]) - mean(Y[Z == 1 & time == 1])) - 
      (mean(Y[Z == 0 & time == 2]) - mean(Y[Z == 0 & time == 1])), 
    estimand_label = "ATT", handler = summarize)
```

```{r}
designs <- redesign(design, 
                    time_trend = c(0, 0.5), 
                    time_specific_effect = c(0, 1), 
                    unit_specific_effect = c(0, 1))

diagnosis <- diagnose_design(designs, diagnosands = declare_diagnosands(bias = mean(estimate - estimand, na.rm = TRUE)))

get_diagnosands(diagnosis) %>% select(time_trend, time_specific_effect, unit_specific_effect, bias) %>% round(2)
```

### Synthetic control 

```{r, echo=FALSE}
synth_weights_tidy <- function(data, predictors, time.predictors.prior, dependent, unit.variable, time.variable, treatment.identifier, controls.identifier) {
  dataprep.out <- dataprep(
    foo = data,
    predictors = predictors,
    predictors.op = "mean",
    time.predictors.prior = time.predictors.prior,
    dependent = dependent,
    unit.variable = unit.variable,
    time.variable = time.variable,
    treatment.identifier = treatment.identifier,
    controls.identifier = controls.identifier, 
    time.optimize.ssr = time.predictors.prior,
    time.plot = time.predictors.prior)
  capture.output(fit <- synth(data.prep.obj = dataprep.out))
  tab <- synth.tab(dataprep.res = dataprep.out, synth.res = fit) 
  
  weights_df <- tab$tab.w %>% mutate(synth_weights = w.weights) %>% 
    dplyr::select(synth_weights, !!unit.variable := unit.numbers)
  
  data %>%
    left_join(weights_df) %>%
    mutate(synth_weights = replace_na(synth_weights, 1))
}

```


```{r}
design <- 
  declare_population(
    units = add_level(N = 10, unit_ID = 1:10, U_unit = rnorm(N), X = rnorm(N), Z = if_else(unit_ID == 1, 1, 0)), # if_else(U_unit == max(U_unit), 1, 0)),
    periods = add_level(N = 3, time = -1:1, U_time = rnorm(N), nest = FALSE),
    unit_periods = cross_levels(
      by = join(units, periods), 
      U = rnorm(N),
      potential_outcomes(Y ~ time_trend * 0.5 * time + time_specific_effect * U_time + 
          unit_specific_effect * U_unit + 
            1.25 * Z + X + U),
      Y = if_else(Z == 0 | time <= 0, Y_Z_0, Y_Z_1)
    )
  ) + 
  declare_estimand(ATT = mean(Y_Z_1 - Y_Z_0), subset = time == 1) + 
  declare_measurement(predictors = "X",
                    time.predictors.prior = -1:0,
                    dependent = "Y",
                    unit.variable = "unit_ID",
                    time.variable = "time",
                    treatment.identifier = 1,
                    controls.identifier = 2:10, 
                    handler = synth_weights_tidy) +
  declare_estimator(Y ~ Z, subset = time == 1, weights = synth_weights, 
                    model = lm_robust, label = "synth")

designs <- redesign(design, 
                    time_trend = c(0, 0.5), 
                    time_specific_effect = c(0, 1), 
                    unit_specific_effect = c(0, 1))

diagnosis <- diagnose_design(designs, sims = 5000, diagnosands = declare_diagnosands(bias = mean(estimate - estimand, na.rm = TRUE)))

get_diagnosands(diagnosis) %>% select(time_trend, time_specific_effect, unit_specific_effect, bias, `se(bias)`) %>% round(2)
```


